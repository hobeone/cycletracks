from django.http import HttpResponse
from django.http import HttpResponseRedirect

from django.shortcuts import render_to_response
from django.template.loader import render_to_string

from django.utils import simplejson
from django.utils.datastructures import SortedDict
from django.contrib.auth import decorators as auth_decorators

from google.appengine.api import datastore_errors
from google.appengine.api import memcache

import logging
import datetime
from gcycle.models import *

# Super hacky reporting page.  Date handling is a bitch.


def group_by_attr(activities, groupby):
  """Group the given activities into a dict using the groupby function to
  generate the key for the activity

  Args:
  - activities: array of Activities
  - groupby: callable that takes an activity as it's arugment and returns a
    datetime.date to use as the grouping key.

  Returns:
  - dict of arrays.  Keys are the keys generated by the groupby function.
  """
  group = {}
  for a in activities:
    key = groupby(a)
    if key not in group:
      group[key] = []
    group[key].append(a)

  return group

def next_month(dtime):
  """Given a date or datetime, return a new date for the next month,
  incrementing the year if appropriate

  Args:
  - dtime: date or datetime

  Returns:
  - new date for the next month.
  """
  next_month = dtime.month + 1
  next_year = dtime.year
  if dtime.month == 12:
    next_year += 1
    next_month = 1

  return datetime.date(year=next_year, month=next_month, day=dtime.day)

def sum_by_buckets(activities, buckets):
  """Takes a list of activities, and buckets and sums the activities in the
  same buckets

  Args:
  - activities: output of group_by_attr()
  - buckets: 2d array of dates.  First date is the start of the bucket and the
    second is the end of the bucket.

  Returns:
  - SortedDict of summed activites for each bucket
  """
  data = SortedDict()

  for bucket in buckets:
    js_timestamp = int(bucket[0].strftime('%s')) * 1000
    data[js_timestamp] = None
    for act_date in activities.keys():
      if act_date >= bucket[0] and act_date < bucket[1]:
        if data[js_timestamp] is None:
          data[js_timestamp] = activities[act_date][0]
          for act in activities[act_date][1:]:
            data[js_timestamp] += act
        else:
          for act in activities[act_date]:
            data[js_timestamp] += act

  return data

def getBucketEnd(start, bucketsize):
  bucketend = None
  if bucketsize == 'day':
    bucketend = start + datetime.timedelta(days=1)
  elif bucketsize == 'week':
    bucketend = start + datetime.timedelta(days=7)
  else:
    bucketend = next_month(start)
  return bucketend


def createBuckets(startdate, lastdate, bucketsize):
  bucket_start = startdate
  bucket_end = getBucketEnd(startdate, bucketsize)
  buckets = [ [bucket_start, bucket_end] ]
  while buckets[-1][1] < lastdate:
    buckets.append([ buckets[-1][1], getBucketEnd(buckets[-1][1], bucketsize) ])

  return buckets


def graphSettings(group_by, startdate, enddate):
  firstdate = datetime.date(
      year = startdate.year,
      month = startdate.month,
      day = startdate.day
  )

  lastdate = datetime.date(
      year = enddate.year,
      month = enddate.month,
      day = enddate.day
  )

  # Defaults:
  settings = {
    'group_by': 'week',
    'tickformat': "%b %d",
    'ticksize' : '[7, "day"]',
    'barwidth' : 24 * 60 * 60 * 1000 * 7,
    'firstdate' : firstdate - datetime.timedelta(days=firstdate.weekday()),
    'lastdate' : lastdate - datetime.timedelta(days=firstdate.weekday()) + datetime.timedelta(days=7),
    'timegroup' : lambda a: datetime.date(a.start_time.year,
          a.start_time.month, a.start_time.day),
  }
  if group_by == 'day':
    settings['group_by'] = 'day'
    settings['tickformat'] = "%b %d"
    settings['ticksize'] = '[1, "day"]'
    settings['barwidth'] = 24 * 60 * 60 * 1000
    settings['firstdate'] = firstdate
    settings['lastdate'] = lastdate


  elif group_by == 'month':
    settings['group_by'] = 'month'
    settings['tickformat'] = "%b %y"
    settings['ticksize'] = '[1, "month"]'
    settings['barwidth'] = 24 * 60 * 60 * 1000 * 30
    settings['firstdate'] = firstdate.replace(day=1)
    settings['lastdate'] = next_month(lastdate.replace(day=1))
    settings['timegroup'] = lambda a: datetime.date(a.start_time.year,
        a.start_time.month, 1)

  return settings

@auth_decorators.login_required
def report(request, group_by):
  if not group_by: group_by = "week"
  acts = Activity.all().order('start_time')
  acts.ancestor(request.user)
  firstact = Activity.all().order('start_time').ancestor(request.user).get()
  lastact = Activity.all().order('-start_time').ancestor(request.user).get()


  if firstact is None:
    return render_to_response('report.html', {
      'data': None,
      'user': request.user
      })

  else:
    settings = graphSettings(group_by, firstact.start_time, lastact.start_time)
    buckets = createBuckets(settings['firstdate'], settings['lastdate'],
        group_by)
    data = sum_by_buckets(group_by_attr(acts,settings['timegroup']), buckets)

    return render_to_response('report.html',
        {'data' : data,
         'gsettings' : settings,
         'user':  request.user}
    )
